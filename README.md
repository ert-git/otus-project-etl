# Декларативный трансформатор структур данных (T в ETL)

## Задача

Пусть есть xls файл вида
```
Код Идентификатор Название
1   1:1-1-1       Крас.Путь-ул.Фрунзе
2   2:2-1-1       Крас.Путь-ул.Рабиновича
```

Необходимо преобразовать этот файл к формату списка JSON-объектов:
```
[
  {
    "Info": [
      {
        "Description": "Адрес размещения: крас.путь-ул.фрунзе",
        "Resource": [
          {
            "ResourceDesc": "RTSPArchive"
          }
        ]
      }
    ],
    "Code": "1:1-1-1"
  },
  {
    "Info": [
      {
        "Description": "Адрес размещения: крас.путь-ул.рабиновича",
        "Resource": [
          {
            "ResourceDesc": "RTSPArchive"
          }
        ]
      }
    ],
    "Code": "2:2-1-1"
  }
]
```

После этого полученный список отправить в JMS очередь, а также иметь возможность скачать в виде файла.


## Структура приложения

* Собственно spring-boot конфигурация (ru.otus.etl.boot)
* Конверторы входных файлов (ru.otus.etl.core.input)
* Команды - функции, которые можно применять к входным данным (ru.otus.etl.transform.cmd)
* Модель - описание правил и конфигурации маппинга
* Конверторы результата (ru.otus.etl.transform.output)
* Веб-контроллеры (ru.otus.etl.web)
* Сервисы, связывающие все части приложения (ru.otus.etl.services)
* Репозитории CRUD - хранение маппингов

### Конверторы входных данных

Выполняют разбор файлов с входными данными и приводят их к унифицированному интерфейсу Extractable, позволяющему получать значения полей по ключу.  

Поддерживаются:
* CSV
* XML
* XLS/XLSX

### Команды

Команды выполняют преобразование входных значений согласно заданным правилам. Каждая команда представлена своим классом с наименованием, производным от имени команды. Во время вычисления команды загружаются рефлексивно, используя правило преобразование имени команды в имя класса. Например, для команды `now` будет загружен класс `FNow`. Все команды реализуют интерфейс `Cmd`, главный метод которого принимает строку из входного файла и возвращает резульат выполнения команды в виде строки. Например, команда `const(ABC)` вернет строку `ABC`.

Команды могут быть вложены друг в друга. Тогда они выполняются последовательно, заменяя свое объявление в исходной строке результатом выполнения, начиная с команды, находящейся на самом нижнем уровне вложения.  

#### Поддерживаемые команды:
* значение поля (get или $)
* конкатенация строк (concat)
* соединение списка в строку с разделителем (join)
* текущее время (now)
* замены подстроки (replace)
* константа (const)
* к нижнему регистру (toLower)

Команда "значение поля" имеет алиас $, который используется без скобок. Остальные команды требуют обязательного заключения аргументов в круглые скобки. При интерпретации круглые скобки заменяются на фигурные во избежание конфликтов в регулярных выражениях.

#### Канонический синтаксис команды:
```
<команда> ::= <название команды>{<аргумент 1>, | <аргумент 2>, | ... | <аргумент n>}
<название команды> ::= <строка>
<аргумент> ::= <строка> | <команда>
```


#### Пример простых команд: 
```
$Какое-то_поле_из_исх_документа
const(ABC)
```

#### Пример вложенных команд:
```
concat(Адрес размещения: , toLower($Название))
```
что эквивалентно
```
concat{Адрес размещения: , toLower{get{Название}}}
```

#### Порядок вычисления цепочки:
```
concat{Адрес размещения: , toLower{get{Название}}}:

get -> toLower -> concat = 
concat{Адрес размещения: , toLower{Крас.Путь-ул.Фрунзе}} -> 
concat{Адрес размещения: , крас.путь-ул.фрунзе} -> 
Адрес размещения: крас.путь-ул.фрунзе
```

### Модель 

Модель включает две сущности: конфигурацию маппинга и правила преобразования. 

#### Конфигурация
Конфигурация описывает общие сведения о маппинге: где находится файл входных данных, его детали (например, разделитель для CSV, есть ли заголовки и т.п.), какие данные ожидаются на выходе, что следует сделать после преобразования.

#### Правила
Правила описывают непосредственно преобразование. Правило состоит из левой и правой части. В левой части содержится имя поля выходной структуры. В правой - цепочка команд для вычисления значения.  
В левой части можно указывать составные поля и массивы. Такие нотации будут преобразованы в объекты в случае преобразования в JSON. Для "плоских" выходных форматов преобразование выполняться не будет.

#### Пример правил:
```
Info[0].Description = concat(Адрес размещения: , toLower($Название))
Info[0].Resource[0].ResourceDesc = const(RTSPArchive)
Code = $Идентификатор
```

### Конверторы результата  

Конверторы результата принимают на вход список Extractable строк исходного документа и применяют к ним правила маппинга, возвращая структуру заданного формата.

Поддерживаются
* properties (ключ = значение)
* json
* csv

### Веб-контроллеры

Используется два типа контроллеров: `@RestController` и `@RestController` для загрузки файлов на сервер. Для обработки исключений используется `@ControllerAdvice`, выдающий наружу только обработанный текст ошибок.

### Сервисы

В приложении всего два сервиса. MappingService отвечает за работу с маппингами, выступая фасадом репозитория и инкапсулируя часть логики по обработке маппинга. FileService отвечает за запись файлов на диск. 

### Репозитории

Приложение, в целом, не требуют БД, поскольку операции по управлению маппингами простейшие CRUD. Можно было бы обойтись файловым хранилищем. Тем не менее, в демонстрационных целях введена БД PostgreSQL. Доступ осуществляется через CrudRepository. 

## Обработка ошибок

Все сервисы стараются перехватить и обработать все ошибки своих операций. Наружу выдается унифицированный `EtlException` либо его потомок, не содержащий технические подробности (такие как stacktrace) оригинальной ошибки. 